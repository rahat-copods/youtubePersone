import { z } from "zod";

export interface CaptionSegment {
  start: string;
  duration: string;
  text: string;
}

const APIFY_ACTOR_ID = "h7sDV53CddomktSi5";
const apifyToken = process.env.APIFY_API_TOKEN!;

export async function startApifyRun(videoId: string): Promise<string> {
  const res = await fetch(
    `https://api.apify.com/v2/acts/${APIFY_ACTOR_ID}/runs?token=${apifyToken}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        downloadSubtitles: true,
        preferAutoGeneratedSubtitles: true,
        saveSubsToKVS: true,
        startUrls: [
          { url: `https://youtube.com/watch?v=${videoId}`, method: "GET" },
        ],
        subtitlesFormat: "vtt",
        subtitlesLanguage: "en",
        maxResults: 1,
      }),
    }
  );

  if (!res.ok) {
    throw new Error("Failed to start Apify actor");
  }

  const runData = await res.json();
  return runData.data.id as string;
}

export async function fetchApifyResults(
  runId: string
): Promise<CaptionSegment[]> {
  const maxAttempts = 60;
  let attempts = 0;

  while (attempts < maxAttempts) {
    await new Promise((resolve) => setTimeout(resolve, 5000));

    const statusRes = await fetch(
      `https://api.apify.com/v2/acts/${APIFY_ACTOR_ID}/runs/${runId}?token=${apifyToken}`
    );
    const statusData = await statusRes.json();
    const status = statusData.data.status;
    const datasetId = statusData.data.defaultDatasetId;

    if (status === "SUCCEEDED") {
      const resultsRes = await fetch(
        `https://api.apify.com/v2/datasets/${datasetId}/items?token=${apifyToken}`
      );
      const results = await resultsRes.json();

      if (results.length > 0 && results[0].subtitles) {
        return parseVttToCaptions(results[0].subtitles[0].vtt);
      }
      return [];
    } else if (status === "FAILED" || status === "ABORTED") {
      throw new Error(`Apify actor ${status.toLowerCase()}`);
    }

    attempts++;
  }

  throw new Error("Caption extraction timed out");
}

function parseVttToCaptions(vttContent: string): CaptionSegment[] {
  console.log("Parsing VTT content", vttContent);
  const captions: CaptionSegment[] = [];
  const lines = vttContent.split("\n");

  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();

    // Look for timestamp line (format: 00:00:00.000 --> 00:00:03.000)
    if (line.includes("-->")) {
      const [startTime, endTime] = line.split(" --> ");
      const startSeconds = timeToSeconds(startTime);
      const endSeconds = timeToSeconds(endTime);
      const duration = (endSeconds - startSeconds).toString();

      // Get caption text (next non-empty lines)
      const textLines: string[] = [];
      i++;
      while (i < lines.length && lines[i].trim() !== "") {
        const textLine = lines[i].trim();
        if (textLine && !textLine.includes("-->")) {
          // Remove VTT styling tags
          const cleanText = textLine.replace(/<[^>]*>/g, "");
          if (cleanText) {
            textLines.push(cleanText);
          }
        }
        i++;
      }

      if (textLines.length > 0) {
        captions.push({
          start: Math.floor(startSeconds).toString(),
          duration,
          text: textLines.join(" "),
        });
      }
    }
    i++;
  }
  console.log("Parsed captions:", captions);
  return captions;
}

function timeToSeconds(timeString: string): number {
  const parts = timeString.split(":");
  const hours = parseInt(parts[0] || "0");
  const minutes = parseInt(parts[1] || "0");
  const seconds = parseFloat(parts[2] || "0");

  return hours * 3600 + minutes * 60 + seconds;
}
