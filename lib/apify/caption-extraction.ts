import { z } from 'zod';

export interface CaptionSegment {
  start: string;
  duration: string;
  text: string;
}

const apifyRequestSchema = z.object({
  downloadSubtitles: z.boolean(),
  preferAutoGeneratedSubtitles: z.boolean(),
  saveSubsToKVS: z.boolean(),
  startUrls: z.array(z.object({
    url: z.string(),
    method: z.literal('GET'),
  })),
  subtitlesFormat: z.literal('vtt'),
  subtitlesLanguage: z.literal('en'),
  maxResults: z.number(),
});

export async function extractCaptions(videoId: string): Promise<CaptionSegment[]> {
  const APIFY_ACTOR_ID = 'h7sDV53CddomktSi5';
  const apifyToken = process.env.APIFY_API_TOKEN!;

  try {
    // Start the actor run
    const runResponse = await fetch(
      `https://api.apify.com/v2/acts/${APIFY_ACTOR_ID}/runs?token=${apifyToken}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          downloadSubtitles: true,
          preferAutoGeneratedSubtitles: true,
          saveSubsToKVS: true,
          startUrls: [{
            url: `https://youtube.com/watch?v=${videoId}`,
            method: 'GET',
          }],
          subtitlesFormat: 'vtt',
          subtitlesLanguage: 'en',
          maxResults: 1,
        }),
      }
    );

    if (!runResponse.ok) {
      throw new Error('Failed to start Apify actor');
    }

    const runData = await runResponse.json();
    const runId = runData.data.id;

    // Poll for completion
    let attempts = 0;
    const maxAttempts = 60; // 5 minutes timeout
    
    while (attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
      
      const statusResponse = await fetch(
        `https://api.apify.com/v2/acts/${APIFY_ACTOR_ID}/runs/${runId}?token=${apifyToken}`
      );
      
      const statusData = await statusResponse.json();
      const status = statusData.data.status;
      
      if (status === 'SUCCEEDED') {
        // Get results
        const resultsResponse = await fetch(
          `https://api.apify.com/v2/acts/${APIFY_ACTOR_ID}/runs/${runId}/dataset/items?token=${apifyToken}`
        );
        
        const results = await resultsResponse.json();
        
        if (results.length > 0 && results[0].subtitles) {
          return parseVttToCaptions(results[0].subtitles);
        }
        break;
      } else if (status === 'FAILED' || status === 'ABORTED') {
        throw new Error(`Apify actor ${status.toLowerCase()}`);
      }
      
      attempts++;
    }

    throw new Error('Caption extraction timed out');
  } catch (error) {
    console.error('Caption extraction error:', error);
    throw error;
  }
}

function parseVttToCaptions(vttContent: string): CaptionSegment[] {
  const captions: CaptionSegment[] = [];
  const lines = vttContent.split('\n');
  
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    
    // Look for timestamp line (format: 00:00:00.000 --> 00:00:03.000)
    if (line.includes('-->')) {
      const [startTime, endTime] = line.split(' --> ');
      const startSeconds = timeToSeconds(startTime);
      const endSeconds = timeToSeconds(endTime);
      const duration = (endSeconds - startSeconds).toString();
      
      // Get caption text (next non-empty lines)
      const textLines: string[] = [];
      i++;
      while (i < lines.length && lines[i].trim() !== '') {
        const textLine = lines[i].trim();
        if (textLine && !textLine.includes('-->')) {
          // Remove VTT styling tags
          const cleanText = textLine.replace(/<[^>]*>/g, '');
          if (cleanText) {
            textLines.push(cleanText);
          }
        }
        i++;
      }
      
      if (textLines.length > 0) {
        captions.push({
          start: Math.floor(startSeconds).toString(),
          duration,
          text: textLines.join(' '),
        });
      }
    }
    i++;
  }
  
  return captions;
}

function timeToSeconds(timeString: string): number {
  const parts = timeString.split(':');
  const hours = parseInt(parts[0] || '0');
  const minutes = parseInt(parts[1] || '0');
  const seconds = parseFloat(parts[2] || '0');
  
  return hours * 3600 + minutes * 60 + seconds;
}